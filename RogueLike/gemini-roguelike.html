Gemini

2.5 Pro

Upgrade



Conversation with Gemini

I want to create an ASCII-based rogue like when you pilot a mecha through a dungeon delve. Programmatically create each level starting with a 15 by 10 map and then get bigger each level up to 20 levels. Your pilot should have stats and your mecha should have weapons and armor and sensors and movement that can be upgraded. The game is played by using the arrow keys. Enemies are placed on the map at random and spawn at random. Every 5th level there is a boss you have to defeat before you can go on. Characters should be saved to local storage for later retrieval. There are items that can be dropped of upgrades and healing.




Show thinking
Of course! This is a fantastic and classic project. Creating a roguelike combines procedural generation, state management, and core game loop mechanics. Let's design the framework for your mecha dungeon-delve.

Here is a comprehensive breakdown, including architectural design, data structures, and a foundational code example in JavaScript that you can run directly in an HTML file.

1. Core Game Design & Architecture
First, let's break the game down into logical components. Thinking in terms of objects or classes will keep your code organized.

Game: The main engine. It will initialize everything, manage the current level, handle the main game loop, and process player input.

Map: Holds the grid data for a single level (walls, floors), its dimensions, and lists of enemies and items on that level. It will contain the logic for procedural generation.

Player: Represents the player's mecha and pilot. It will hold all stats, inventory, position on the map, and methods for actions (move, attack).

Pilot: A sub-object of Player. It contains the pilot's personal stats that influence the mecha's performance.

Mecha: A sub-object of Player. It contains the mecha's hardware, stats, and upgradeable components.

Enemy: Represents an enemy unit. It will have its own stats, AI for movement and attacking, and position.

Item: Represents a pickup, like a healing pack or an upgrade module.

Renderer: Responsible for drawing the map, characters, UI, and any messages to the screen.

StorageManager: A utility to handle saving and loading the game state to the browser's localStorage.

2. Stats and Components Breakdown
This is the heart of your mecha theme.

Pilot Stats
The pilot's innate skills affect the mecha's performance. These can be leveled up.

Gunnery (GUN): Increases weapon accuracy and critical hit chance.

Piloting (PIL): Increases evasion chance and allows for faster movement options with certain upgrades.

Tech (TEC): Increases the effectiveness of repairs, sensor range, and shield efficiency.

Mecha Components (Upgradeable)
Chassis: The core frame. Determines base Hull Integrity (HP) and the number of slots available for other components.

Armor: Provides damage reduction.

Hull Plating: Raw damage reduction.

Energy Shield: A regenerating pool of health that takes damage first.

Weapons: Can be equipped in weapon slots.

Examples: Gauss Cannon (high damage, single target), Laser Array (medium damage, can hit multiple adjacent foes), Missile Swarm (area of effect, limited ammo).

Properties: Damage, Range, Accuracy, Heat Generation / Ammo.

Sensors: Determines Line of Sight (LOS) range. Better sensors let you see enemies from further away.

Movement: Determines speed (how many actions per turn) and movement type.

Examples: Standard Bipedal Legs, Treads (slower but ignores rough terrain), Jump Jets (allows jumping over obstacles/enemies).

Example Stat Block (using LaTeX for clarity):

--- PILOT: JANE "VIPER" DOE ---
LVL: 1 | XP: 0/100
GUN: 5 | PIL: 7 | TEC: 4

--- MECHA: CHIMERA MK. II ---
Hull: 100/100 | Shield: 50/50
Movement: 5 units | Sensors: 8 tiles

[W] Gauss Cannon (DMG: 15-20, RNG: 7)
[W] --- EMPTY ---
[A] Steel Plating (DR: 3)
3. Level Generation & Scaling
You need a function that creates a map programmatically. A simple "Drunkard's Walk" algorithm is a great starting point.

Create a grid of a given size, filled entirely with wall tiles (#).

Pick a random starting point (e.g., the center) and change it to a floor tile (.).

"Walk" in a random direction (up, down, left, or right) for a set number of steps, carving out floor tiles as you go.

If the walker hits the edge of the map, choose a new random floor tile to start a new walk from.

Repeat until a desired percentage of the map is floor tiles.

Place stairs down (>) on a random floor tile, far from the player's starting point.

Scaling:
The map size will increase with each level.

level_number (from 1 to 20)

map_width = 15 + floor(level_number * 1.5)

map_height = 10 + level_number

This simple formula will gradually increase the size, making later levels feel more expansive.

4. Enemies and Bosses
Random Spawning: When a level is generated, randomly place a number of enemies on valid floor tiles. The number and type of enemies can increase with the level number.

Enemy Types:

Scout Drone ('d'): Fast, low health, weak attack. Tries to stay at a distance.

Sentry Bot ('b'): High health, strong attack, but might move slower.

Acid Spitter ('s'): Ranged attack that can corrode armor (a temporary debuff).

Bosses (Every 5th Level): These should be unique encounters.

Level 5: The Scrapheap Goliath (G): A massive, slow-moving brute with very high hull integrity and a powerful melee attack. The arena could have piles of scrap (~) that slow you down.

Level 10: The Phantom Weaver (W): A boss that can teleport and create weaker copies (w) of itself. You must destroy the real one.

Level 15: The Siege Turret (T): A stationary boss in the center of a room that fires massive AOE barrages. You must navigate cover to get close enough to damage it.

Level 20: The Rogue AI Core (C): The final boss. It doesn't attack directly but corrupts the level, turning floor tiles into damaging energy fields (%) and spawning high-tier enemies. You must survive long enough to destroy the Core itself.

5. Local Storage for Persistence
Web browsers provide a simple key-value store called localStorage. You can save your entire game state here.

Saving:

Consolidate your game state (player object, current level number, etc.) into a single large JavaScript object.

Convert this object into a JSON string using JSON.stringify().

Save it to localStorage: localStorage.setItem('myMechaRoguelikeSave', jsonString);

Loading:

On game start, check if the save data exists: const savedGame = localStorage.getItem('myMechaRoguelikeSave');

If it exists, parse it back into an object: const gameState = JSON.parse(savedGame);

Use this object to restore your game to its previous state.

6. Foundational Code Example (HTML & JavaScript)
Here is a simple, runnable starting point. Copy this code into a single .html file and open it in your browser. It handles map generation, player movement, and rendering.

HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mecha Roguelike</title>
    <style>
        body { background-color: #111; color: #eee; font-family: 'Courier New', Courier, monospace; text-align: center; }
        #game-container { line-height: 1; font-size: 20px; display: inline-block; border: 2px solid #555; padding: 10px; }
        #ui-panel { margin-top: 15px; font-size: 16px; text-align: left; display: inline-block; vertical-align: top; margin-left: 20px;}
        .player { color: #4f4; }
        .enemy { color: #f44; }
        .wall { color: #888; }
        .floor { color: #444; }
        .stairs { color: #ff0; }
    </style>
</head>
<body>
    <h1>Mecha Roguelike</h1>
    <div>
        <pre id="game-container"></pre>
        <div id="ui-panel">
            <h3 style="margin-top: 0;">-- STATUS --</h3>
            <div>Level: <span id="ui-level">1</span></div>
            <div>Position: <span id="ui-pos">0, 0</span></div>
            <div>Hull: <span id="ui-hull">100/100</span></div>
            <div id="message-log" style="margin-top: 20px; color: #f90;"></div>
        </div>
    </div>

    <script>
        // --- CORE GAME OBJECTS ---

        const TILES = {
            WALL: { char: '#', color: 'wall' },
            FLOOR: { char: '.', color: 'floor' },
            STAIRS: { char: '>', color: 'stairs' }
        };

        class Entity {
            constructor(x, y, char, color) {
                this.x = x;
                this.y = y;
                this.char = char;
                this.color = color;
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, '@', 'player');
                this.level = 1;
                this.hull = 100;
                this.maxHull = 100;
            }
        }

        class Enemy extends Entity {
             constructor(x, y) {
                super(x, y, 'd', 'enemy');
            }
        }

        // --- GAME ENGINE ---

        const Game = {
            display: null,
            ui: {},
            map: {},
            player: null,
            enemies: [],
            level: 1,

            init: function() {
                this.display = document.getElementById('game-container');
                this.ui.level = document.getElementById('ui-level');
                this.ui.pos = document.getElementById('ui-pos');
                this.ui.hull = document.getElementById('ui-hull');
                this.ui.log = document.getElementById('message-log');
                
                this.generateLevel();
                window.addEventListener('keydown', this.handleInput.bind(this));
                this.logMessage("Welcome, Pilot. System online.");
                this.draw();
            },

            generateLevel: function() {
                const width = 15 + Math.floor(this.level * 1.5);
                const height = 10 + this.level;
                
                // 1. Create map of walls
                this.map = {};
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        this.map[`${x},${y}`] = TILES.WALL;
                    }
                }

                // 2. Drunkard's Walk for floors
                const floorTiles = [];
                let currentX = Math.floor(width / 2);
                let currentY = Math.floor(height / 2);
                const totalTiles = width * height;
                const desiredFloors = totalTiles * 0.5; // 50% floors
                
                while (floorTiles.length < desiredFloors) {
                    if (this.map[`${currentX},${currentY}`] === TILES.WALL) {
                        this.map[`${currentX},${currentY}`] = TILES.FLOOR;
                        floorTiles.push({x: currentX, y: currentY});
                    }
                    
                    // Move randomly
                    const direction = Math.floor(Math.random() * 4);
                    if (direction === 0 && currentX > 1) currentX--;
                    else if (direction === 1 && currentX < width - 2) currentX++;
                    else if (direction === 2 && currentY > 1) currentY--;
                    else if (direction === 3 && currentY < height - 2) currentY++;
                }

                // 3. Place player
                const playerStart = floorTiles.shift();
                if (!this.player) {
                    this.player = new Player(playerStart.x, playerStart.y);
                } else {
                    this.player.x = playerStart.x;
                    this.player.y = playerStart.y;
                }

                // 4. Place stairs
                const stairsPos = floorTiles.pop();
                this.map[`${stairsPos.x},${stairsPos.y}`] = TILES.STAIRS;
                
                // 5. Place enemies
                this.enemies = [];
                const numEnemies = 1 + this.level;
                for(let i=0; i < numEnemies; i++) {
                    const enemyPos = floorTiles.splice(Math.floor(Math.random() * floorTiles.length), 1)[0];
                    this.enemies.push(new Enemy(enemyPos.x, enemyPos.y));
                }
            },
            
            logMessage: function(message) {
                this.ui.log.textContent = message;
            },

            draw: function() {
                let mapString = '';
                const width = 15 + Math.floor(this.level * 1.5);
                const height = 10 + this.level;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let drawn = false;
                        // Draw player
                        if (this.player.x === x && this.player.y === y) {
                            mapString += `<span class="${this.player.color}">${this.player.char}</span>`;
                            drawn = true;
                        }
                        // Draw enemies
                        if (!drawn) {
                             for(const enemy of this.enemies) {
                                if (enemy.x === x && enemy.y === y) {
                                    mapString += `<span class="${enemy.color}">${enemy.char}</span>`;
                                    drawn = true;
                                    break;
                                }
                            }
                        }
                        // Draw map tile
                        if (!drawn) {
                            const tile = this.map[`${x},${y}`];
                            mapString += `<span class="${tile.color}">${tile.char}</span>`;
                        }
                    }
                    mapString += '\n';
                }
                this.display.innerHTML = mapString;
                
                // Update UI
                this.ui.level.textContent = this.level;
                this.ui.pos.textContent = `${this.player.x}, ${this.player.y}`;
                this.ui.hull.textContent = `${this.player.hull}/${this.player.maxHull}`;
            },

            handleInput: function(event) {
                let newX = this.player.x;
                let newY = this.player.y;

                if (event.key === 'ArrowUp') newY--;
                if (event.key === 'ArrowDown') newY++;
                if (event.key === 'ArrowLeft') newX--;
                if (event.key === 'ArrowRight') newX++;
                
                // Check for collision
                const targetTile = this.map[`${newX},${newY}`];
                if (targetTile && targetTile !== TILES.WALL) {
                    this.player.x = newX;
                    this.player.y = newY;
                    this.logMessage(""); // Clear log on move
                    
                    // Check for stairs
                    if (targetTile === TILES.STAIRS) {
                        this.level++;
                        if (this.level > 20) {
                            this.logMessage("VICTORY! You have conquered the dungeon!");
                            window.removeEventListener('keydown', this.handleInput); // End game
                        } else {
                            this.logMessage(`Descending to level ${this.level}...`);
                            this.generateLevel();
                        }
                    }
                } else {
                    this.logMessage("CLANG! You hit a wall.");
                }

                this.draw();
            }
        };

        // --- START THE GAME ---
        Game.init();
    </script>
</body>
</html>
Next Steps from This Foundation:
Combat System: When the player tries to move into a tile occupied by an enemy, initiate an attack instead. Calculate hit chance based on Gunnery and damage based on equipped weapons.

Enemy AI: In the handleInput function, after the player moves, loop through Game.enemies and have each one take a turn. A simple AI would be: "If the player is in sight, move one step closer."

Line of Sight (LOS): Implement an algorithm (like Bresenham's Line) to determine which tiles the player can see. Only draw enemies and items within the player's LOS.

Items & Inventory: Create Item objects. When the player moves onto their tile, add the item to the Player's inventory. Create a UI to view and use items.

Saving/Loading: Implement the StorageManager to save the Game object to localStorage when the player descends stairs or manually saves, and add a "Continue Game" button to load it.

Boss Logic: On levels 5, 10, 15, and 20, instead of generateLevel, call a special generateBossLevel function that places the specific boss and its unique arena elements.












Tools

Gemini can make mistakes, so double-check it

